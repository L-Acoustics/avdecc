////////////////////////////////////////
// AVDECC LIBRARY SWIG file
////////////////////////////////////////

%module(directors="1", csbegin="#nullable enable\n") avdecc

// C# Specifics
#if defined(SWIGCSHARP)
// Optimize code generation by enabling RVO
%typemap(out, optimal="1") SWIGTYPE
%{
	$result = new $1_ltype($1);
%}
#pragma SWIG nowarn=474
// Marshal all std::string as UTF8Str
%typemap(imtype, outattributes="[return: System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPUTF8Str)]", inattributes="[System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPUTF8Str)] ") std::string, std::string const& "string"
// Expose internal constructor and methods publicly, some dependant modules may need it
#	if !defined(SWIGIMPORTED)
#	define PUBLIC_BUT_HIDDEN [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)] public
	SWIG_CSBODY_PROXY(PUBLIC_BUT_HIDDEN, PUBLIC_BUT_HIDDEN, SWIGTYPE)
#	endif
// Use Nullable Reference Types for Optional (requires C# >= 8.0)
#define SWIG_STD_OPTIONAL_USE_NULLABLE_REFERENCE_TYPES
// Override default visibility for internal optional class (to make it accessible from other assemblies but not visible)
#undef SWIG_STD_OPTIONAL_INTERNAL_CLASS_MODIFIER
#define SWIG_STD_OPTIONAL_INTERNAL_CLASS_MODIFIER PUBLIC_BUT_HIDDEN
#endif

// Common for all languages
// Use 64-bit size_t
#if defined(USE_SIZE_T_64)
%apply unsigned long long { size_t };
%apply const unsigned long long & { const size_t & };
#endif
// Ignore warning %extend defined for an undeclared class 'name'.
#pragma SWIG nowarn=303


%include <stl.i>
%include <std_string.i>
%include <std_set.i>
%include <stdint.i>
%include <std_pair.i>
%include <std_map.i>
%include <windows.i>
%include <std_unique_ptr.i>
%include <std_optional.i>
#if 0
%include <swiginterface.i>
#endif
#ifdef SWIGCSHARP
%include <arrays_csharp.i>
#endif
%include "la/avdecc/internals/chrono.i"
%include "la/avdecc/internals/std_function.i"
%include "la/avdecc/internals/std_tuple.i"

// Generated wrapper file needs to include our header file (include as soon as possible using 'insert(runtime)' as target language exceptions are defined early in the generated wrapper file)
%insert(runtime) %{
	#include <la/avdecc/memoryBuffer.hpp>
	#include <la/avdecc/logger.hpp>
	#include <la/avdecc/executor.hpp>
	#include <la/avdecc/avdecc.hpp>
	#include <la/avdecc/internals/exception.hpp>
	#include <la/avdecc/internals/entity.hpp>
	#include <la/avdecc/internals/controllerEntity.hpp>
	#include <la/avdecc/internals/endStation.hpp>
	#include <la/avdecc/internals/protocolVuAecpdu.hpp>
	#include <la/avdecc/internals/protocolInterface.hpp>
%}

// Force define AVDECC C/C++ API Macros to nothing
#define LA_AVDECC_API
#define LA_AVDECC_CALL_CONVENTION

////////////////////////////////////////
// Utils
////////////////////////////////////////
%include "la/avdecc/utils.i"

// Define ThreadPriority enum class
%nspace la::avdecc::utils::ThreadPriority;
namespace la::avdecc::utils
{
enum class ThreadPriority
{
	Idle = 0,
	Lowest = 1,
	BelowNormal = 3,
	Normal = 5,
	AboveNormal = 7,
	Highest = 9,
	TimeCritical = 10,
};
} // namespace la::avdecc::utils


////////////////////////////////////////
// MemoryBuffer class
////////////////////////////////////////
%include "la/avdecc/memoryBuffer.i"


////////////////////////////////////////
// Logger class
////////////////////////////////////////
%include "la/avdecc/logger.i"


////////////////////////////////////////
// Executor/ExecutorManager classes
////////////////////////////////////////
// Bind structs and classes
%rename($ignore, %$isclass) ""; // Ignore all structs/classes, manually re-enable

%nspace la::avdecc::Executor;
%rename("%s") la::avdecc::Executor; // Unignore class
%ignore la::avdecc::Executor::getExecutorThread; // TODO: RIGHT NOW IGNORE THIS METHOD (need to typemap std::thread::id)
// Unignore functions automatically generated by the following std_function calls (because we asked to ignore all methods earlier)
%rename("%s") Handler_Empty;
%unique_ptr(la::avdecc::Executor) // Define unique_ptr for Executor
// TODO: Would be nice to have the handler in the same namespace as the class (ie. be able to pass a namespace to std_function)
%std_function(Handler_Empty, void);
%optional_string()

%nspace la::avdecc::ExecutorWithDispatchQueue;
%rename("%s") la::avdecc::ExecutorWithDispatchQueue; // Unignore class
// Extend the class
%extend la::avdecc::ExecutorWithDispatchQueue
{
public:
	static std::unique_ptr<la::avdecc::Executor> create(std::optional<std::string> const& name = std::nullopt, utils::ThreadPriority const prio = utils::ThreadPriority::Normal) noexcept
	{
		return std::unique_ptr<la::avdecc::Executor>{ la::avdecc::ExecutorWithDispatchQueue::create(name, prio).release() };
	}
};
%ignore la::avdecc::ExecutorWithDispatchQueue::create; // Ignore it, will be wrapped (because std::unique_ptr doesn't support custom deleters - Ticket #2411)

%nspace la::avdecc::ExecutorManager;
%rename("%s") la::avdecc::ExecutorManager; // Unignore class
%rename("%s") la::avdecc::ExecutorManager::ExecutorWrapper; // Unignore class
%unique_ptr(la::avdecc::ExecutorManager::ExecutorWrapper) // Define unique_ptr for ExecutorManager::ExecutorWrapper
%ignore la::avdecc::ExecutorManager::getExecutorThread; // TODO: RIGHT NOW IGNORE THIS METHOD (need to typemap std::thread::id)
// Extend the class
%extend la::avdecc::ExecutorManager
{
public:
	std::unique_ptr<la::avdecc::ExecutorManager::ExecutorWrapper> registerExecutor(std::string const& name, std::unique_ptr<la::avdecc::Executor>&& executor)
	{
		auto deleter = [](la::avdecc::Executor* s)
		{
			delete s;
		};
		auto ex = la::avdecc::Executor::UniquePointer(executor.release(), deleter);
		return std::unique_ptr<la::avdecc::ExecutorManager::ExecutorWrapper>{ $self->registerExecutor(name, std::move(ex)).release() };
	}
};
%ignore la::avdecc::ExecutorManager::registerExecutor; // Ignore it, will be wrapped (because std::unique_ptr doesn't support custom deleters - Ticket #2411)


// Include c++ declaration file
%include "la/avdecc/executor.hpp"
%rename("%s", %$isclass) ""; // Undo the ignore all structs/classes


////////////////////////////////////////
// avdecc global
////////////////////////////////////////
%ignore la::avdecc::CompileOption;
%ignore la::avdecc::CompileOptionInfo;
%ignore la::avdecc::getCompileOptions();
%ignore la::avdecc::getCompileOptionsInfo();

// Include c++ declaration file
%include "la/avdecc/avdecc.hpp"


////////////////////////////////////////
// Exception class
////////////////////////////////////////
// Ignore Exception, will be created as native exception
%nspace la::avdecc::BaseException;
%rename("BaseAtdeccException") la::avdecc::Exception; // Not put in a namespace https://github.com/swig/swig/issues/2459

// Throw typemap
%typemap (throws, canthrow=1) la::avdecc::Exception %{
	SWIG_CSharpSetPendingException($1.what());
	return $null;
%}

// Define catches for methods that can throw
%catches(la::avdecc::Exception) la::avdecc::entity::Entity::Entity;
%catches(la::avdecc::Exception) la::avdecc::entity::Entity::getInterfaceInformation(model::AvbInterfaceIndex const interfaceIndex) const;
%catches(la::avdecc::Exception) la::avdecc::entity::Entity::getInterfaceInformation(model::AvbInterfaceIndex const interfaceIndex);
%catches(la::avdecc::Exception) la::avdecc::entity::Entity::getAnyMacAddress() const;

// Include c++ declaration file
%include "la/avdecc/internals/exception.hpp"


////////////////////////////////////////
// Entity Model
////////////////////////////////////////
// Define optionals before including entityModel.i (we need to declare the optionals before the underlying types are defined)
%optional_arithmetic(la::avdecc::entity::model::MsrpFailureCode, OptMsrpFailureCode)
%optional(la::avdecc::UniqueIdentifier)
%optional(la::networkInterface::MacAddress)
%optional(la::avdecc::entity::model::MediaClockReferenceInfo)

// Import entity model
%import "la/avdecc/internals/entityModel.i"


////////////////////////////////////////
// Entity/LocalEntity
////////////////////////////////////////
// Bind enums
DEFINE_ENUM_CLASS(la::avdecc::entity::LocalEntity::AemCommandStatus, "ushort")
DEFINE_ENUM_CLASS(la::avdecc::entity::LocalEntity::AaCommandStatus, "ushort")
DEFINE_ENUM_CLASS(la::avdecc::entity::LocalEntity::MvuCommandStatus, "ushort")
DEFINE_ENUM_CLASS(la::avdecc::entity::LocalEntity::ControlStatus, "ushort")
DEFINE_ENUM_CLASS(la::avdecc::entity::LocalEntity::AdvertiseFlag, "byte")

// Bind structs and classes
%rename($ignore, %$isclass) ""; // Ignore all structs/classes, manually re-enable

%nspace la::avdecc::entity::Entity;
%rename("%s") la::avdecc::entity::Entity; // Unignore class
%ignore la::avdecc::entity::Entity::Entity(Entity&&); // Ignore move constructor
%ignore la::avdecc::entity::Entity::operator=; // Ignore copy operator
%ignore la::avdecc::entity::Entity::getCommonInformation() const; // Ignore const overload
%ignore la::avdecc::entity::Entity::getInterfaceInformation(model::AvbInterfaceIndex const interfaceIndex) const; // Ignore const overload
%ignore la::avdecc::entity::Entity::getInterfacesInformation() const; // Ignore const overload
%nspace la::avdecc::entity::Entity::CommonInformation;
%rename("%s") la::avdecc::entity::Entity::CommonInformation; // Unignore child struct
%nspace la::avdecc::entity::Entity::InterfaceInformation;
%rename("%s") la::avdecc::entity::Entity::InterfaceInformation; // Unignore child struct

%nspace la::avdecc::entity::LocalEntity;
%rename("%s") la::avdecc::entity::LocalEntity; // Unignore class
%rename("lockEntity") la::avdecc::entity::LocalEntity::lock; // Rename method
%rename("unlockEntity") la::avdecc::entity::LocalEntity::unlock; // Rename method
%rename("not") operator!(LocalEntity::AemCommandStatus const status); // Not put in a namespace https://github.com/swig/swig/issues/2459
%rename("or") operator|(LocalEntity::AemCommandStatus const lhs, LocalEntity::AemCommandStatus const rhs); // Not put in a namespace https://github.com/swig/swig/issues/2459
%ignore operator|=(LocalEntity::AemCommandStatus& lhs, LocalEntity::AemCommandStatus const rhs); // Don't know how to properly bind this with correct type defined (SWIG generates a SWIGTYPE_p file for this)
%rename("not") operator!(LocalEntity::AaCommandStatus const status); // Not put in a namespace https://github.com/swig/swig/issues/2459
%rename("or") operator|(LocalEntity::AaCommandStatus const lhs, LocalEntity::AaCommandStatus const rhs); // Not put in a namespace https://github.com/swig/swig/issues/2459
%ignore operator|=(LocalEntity::AaCommandStatus& lhs, LocalEntity::AaCommandStatus const rhs); // Don't know how to properly bind this with correct type defined (SWIG generates a SWIGTYPE_p file for this)
%rename("not") operator!(LocalEntity::MvuCommandStatus const status); // Not put in a namespace https://github.com/swig/swig/issues/2459
%rename("or") operator|(LocalEntity::MvuCommandStatus const lhs, LocalEntity::MvuCommandStatus const rhs); // Not put in a namespace https://github.com/swig/swig/issues/2459
%ignore operator|=(LocalEntity::MvuCommandStatus& lhs, LocalEntity::MvuCommandStatus const rhs); // Don't know how to properly bind this with correct type defined (SWIG generates a SWIGTYPE_p file for this)
%rename("not") operator!(LocalEntity::ControlStatus const status); // Not put in a namespace https://github.com/swig/swig/issues/2459
%rename("or") operator|(LocalEntity::ControlStatus const lhs, LocalEntity::ControlStatus const rhs); // Not put in a namespace https://github.com/swig/swig/issues/2459
%ignore operator|=(LocalEntity::ControlStatus& lhs, LocalEntity::ControlStatus const rhs); // Don't know how to properly bind this due to const overload
%ignore operator|=(LocalEntity::ControlStatus const lhs, LocalEntity::ControlStatus const rhs); // Don't know how to properly bind this due to const overload

// Include c++ declaration file
%include "la/avdecc/internals/entity.hpp"
%rename("%s", %$isclass) ""; // Undo the ignore all structs/classes

// Define templates
%template(InterfaceInformationMap) std::map<la::avdecc::entity::model::AvbInterfaceIndex, la::avdecc::entity::Entity::InterfaceInformation>;
DEFINE_ENUM_BITFIELD_CLASS(la::avdecc::entity::LocalEntity, AdvertiseFlags, AdvertiseFlag, std::uint8_t)


////////////////////////////////////////
// ControllerEntity
////////////////////////////////////////
// Bind structs and classes
%rename($ignore, %$isclass) ""; // Ignore all structs/classes, manually re-enable

%nspace la::avdecc::entity::controller::DynamicInfoParameter;
#if 1
%ignore la::avdecc::entity::controller::DynamicInfoParameter; // TEMP IGNORE CLASS UNTIL WE CAN WRAP std::any
#else
%rename("%s") la::avdecc::entity::controller::DynamicInfoParameter; // Unignore class
#endif

DEFINE_OBSERVER_CLASS(la::avdecc::entity::controller::Delegate)
%ignore la::avdecc::entity::controller::Delegate::Delegate(Delegate&&); // Ignore move constructor
%ignore la::avdecc::entity::controller::Delegate::operator=; // Ignore copy operator

DEFINE_OBSERVER_CLASS(la::avdecc::entity::controller::DefaultedDelegate)
%ignore la::avdecc::entity::controller::DefaultedDelegate::DefaultedDelegate(DefaultedDelegate&&); // Ignore move constructor
%ignore la::avdecc::entity::controller::DefaultedDelegate::operator=; // Ignore copy operator

DEFINE_OBSERVER_CLASS(la::avdecc::entity::controller::Interface)
%ignore la::avdecc::entity::controller::Interface::Interface(Interface&&); // Ignore move constructor
%ignore la::avdecc::entity::controller::Interface::operator=; // Ignore copy operator
// Unignore functions automatically generated by the following std_function calls (because we asked to ignore all methods earlier)
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_UniqueIdentifier_DescriptorType;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_EntityDescriptor;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_ConfigurationDescriptor;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_AudioUnitIndex_AudioUnitDescriptor;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_StreamIndex_StreamDescriptor;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_JackIndex_JackDescriptor;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_AvbInterfaceIndex_AvbInterfaceDescriptor;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_ClockSourceIndex_ClockSourceDescriptor;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_MemoryObjectIndex_MemoryObjectDescriptor;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_LocaleIndex_LocaleDescriptor;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_StringsIndex_StringsDescriptor;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_StreamPortIndex_StreamPortDescriptor;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_ExternalPortIndex_ExternalPortDescriptor;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_InternalPortIndex_InternalPortDescriptor;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_ClusterIndex_AudioClusterDescriptor;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_MapIndex_AudioMapDescriptor;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_ControlIndex_ControlDescriptor;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_ClockDomainIndex_ClockDomainDescriptor;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_TimingIndex_TimingDescriptor;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_PtpInstanceIndex_PtpInstanceDescriptor;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_PtpPortIndex_PtpPortDescriptor;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_StreamIndex_StreamFormat;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_StreamPortIndex_MapIndex_MapIndex_AudioMappings;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_StreamPortIndex_AudioMappings;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_StreamIndex_StreamInfo;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_AvdeccFixedString;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_AvdeccFixedString;
#if TYPED_DESCRIPTOR_INDEXES
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_AudioUnitIndex_AvdeccFixedString;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_StreamIndex_AvdeccFixedString;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_JackIndex_AvdeccFixedString;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_AvbInterfaceIndex_AvdeccFixedString;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_ClockSourceIndex_AvdeccFixedString;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_MemoryObjectIndex_AvdeccFixedString;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_ClusterIndex_AvdeccFixedString;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_ControlIndex_AvdeccFixedString;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_ClockDomainIndex_AvdeccFixedString;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_TimingIndex_AvdeccFixedString;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_PtpInstanceIndex_AvdeccFixedString;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_PtpPortIndex_AvdeccFixedString;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_AudioUnitIndex_SamplingRate;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ClusterIndex_SamplingRate;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_StreamIndex;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_MemoryObjectIndex;
#else
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_DescriptorIndex;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_DescriptorIndex_AvdeccFixedString;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_DescriptorIndex_SamplingRate;
#endif
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_UniqueIdentifier;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ClockDomainIndex_ClockSourceIndex;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ControlIndex_MemoryBuffer;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_AvbInterfaceIndex_AvbInfo;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_AvbInterfaceIndex_AsPath;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_EntityCounterValidFlags_DescriptorCounters;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_AvbInterfaceIndex_AvbInterfaceCounterValidFlags_DescriptorCounters;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ClockDomainIndex_ClockDomainCounterValidFlags_DescriptorCounters;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_StreamIndex_StreamInputCounterValidFlags_DescriptorCounters;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_StreamIndex_StreamOutputCounterValidFlags_DescriptorCounters;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_DescriptorType_DescriptorIndex_OperationID_MemoryObjectOperationType_MemoryBuffer;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_DescriptorType_DescriptorIndex_OperationID;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_MemoryObjectIndex_uint64_t;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_DynamicInfoParameter;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_StreamIndex_nanoseconds;
%rename("%s") Handler_UniqueIdentifier_AemCommandStatus_Tlvs;
%rename("%s") Handler_UniqueIdentifier_MvuCommandStatus_MilanInfo;
%rename("%s") Handler_UniqueIdentifier_MvuCommandStatus_SystemUniqueIdentifier;
%rename("%s") Handler_UniqueIdentifier_MvuCommandStatus_ClockDomainIndex_DefaultMediaClockReferencePriority_MediaClockReferenceInfo;
%rename("%s") Handler_StreamIdentification_StreamIdentification_uint16_t_ConnectionFlags_ControlStatus;

// TODO: Would be nice to have the handler in the same namespace as the class (ie. be able to pass a namespace to std_function)
%std_function(Handler_UniqueIdentifier_AemCommandStatus_UniqueIdentifier_DescriptorType, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::UniqueIdentifier const owningEntity, la::avdecc::entity::model::DescriptorType const descriptorType, la::avdecc::entity::model::DescriptorIndex const descriptorIndex);
%std_function(Handler_UniqueIdentifier_AemCommandStatus, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_EntityDescriptor, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::EntityDescriptor const& descriptor);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_ConfigurationDescriptor, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::ConfigurationDescriptor const& descriptor);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_AudioUnitIndex_AudioUnitDescriptor, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::AudioUnitIndex const audioUnitIndex, la::avdecc::entity::model::AudioUnitDescriptor const& descriptor);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_StreamIndex_StreamDescriptor, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::StreamIndex const streamIndex, la::avdecc::entity::model::StreamDescriptor const& descriptor);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_JackIndex_JackDescriptor, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::JackIndex const jackIndex, la::avdecc::entity::model::JackDescriptor const& descriptor);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_AvbInterfaceIndex_AvbInterfaceDescriptor, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::AvbInterfaceIndex const avbInterfaceIndex, la::avdecc::entity::model::AvbInterfaceDescriptor const& descriptor);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_ClockSourceIndex_ClockSourceDescriptor, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::ClockSourceIndex const clockSourceIndex, la::avdecc::entity::model::ClockSourceDescriptor const& descriptor);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_MemoryObjectIndex_MemoryObjectDescriptor, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::MemoryObjectIndex const memoryObjectIndex, la::avdecc::entity::model::MemoryObjectDescriptor const& descriptor);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_LocaleIndex_LocaleDescriptor, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::LocaleIndex const localeIndex, la::avdecc::entity::model::LocaleDescriptor const& descriptor);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_StringsIndex_StringsDescriptor, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::StringsIndex const stringsIndex, la::avdecc::entity::model::StringsDescriptor const& descriptor);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_StreamPortIndex_StreamPortDescriptor, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::StreamPortIndex const streamPortIndex, la::avdecc::entity::model::StreamPortDescriptor const& descriptor);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_ExternalPortIndex_ExternalPortDescriptor, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::ExternalPortIndex const externalPortIndex, la::avdecc::entity::model::ExternalPortDescriptor const& descriptor);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_InternalPortIndex_InternalPortDescriptor, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::InternalPortIndex const internalPortIndex, la::avdecc::entity::model::InternalPortDescriptor const& descriptor);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_ClusterIndex_AudioClusterDescriptor, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::ClusterIndex const clusterIndex, la::avdecc::entity::model::AudioClusterDescriptor const& descriptor);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_MapIndex_AudioMapDescriptor, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::MapIndex const mapIndex, la::avdecc::entity::model::AudioMapDescriptor const& descriptor);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_ControlIndex_ControlDescriptor, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::ControlIndex const controlIndex, la::avdecc::entity::model::ControlDescriptor const& descriptor);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_ClockDomainIndex_ClockDomainDescriptor, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::ClockDomainIndex const clockDomainIndex, la::avdecc::entity::model::ClockDomainDescriptor const& descriptor);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_TimingIndex_TimingDescriptor, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::TimingIndex const timingIndex, la::avdecc::entity::model::TimingDescriptor const& descriptor);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_PtpInstanceIndex_PtpInstanceDescriptor, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::PtpInstanceIndex const ptpInstanceIndex, la::avdecc::entity::model::PtpInstanceDescriptor const& descriptor);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_PtpPortIndex_PtpPortDescriptor, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::PtpPortIndex const ptpPortIndex, la::avdecc::entity::model::PtpPortDescriptor const& descriptor);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_StreamIndex_StreamFormat, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::StreamIndex const streamIndex, la::avdecc::entity::model::StreamFormat const streamFormat);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_StreamPortIndex_MapIndex_MapIndex_AudioMappings, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::StreamPortIndex const streamPortIndex, la::avdecc::entity::model::MapIndex const numberOfMaps, la::avdecc::entity::model::MapIndex const mapIndex, la::avdecc::entity::model::AudioMappings const& mappings);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_StreamPortIndex_AudioMappings, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::StreamPortIndex const streamPortIndex, la::avdecc::entity::model::AudioMappings const& mappings);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_StreamIndex_StreamInfo, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::StreamIndex const streamIndex, la::avdecc::entity::model::StreamInfo const& info);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_AvdeccFixedString, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::AvdeccFixedString const& name);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_AvdeccFixedString, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::AvdeccFixedString const& name);
#if TYPED_DESCRIPTOR_INDEXES
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_AudioUnitIndex_AvdeccFixedString, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::AudioUnitIndex const audioUnitIndex, la::avdecc::entity::model::AvdeccFixedString const& name);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_StreamIndex_AvdeccFixedString, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::StreamIndex const streamIndex, la::avdecc::entity::model::AvdeccFixedString const& name);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_JackIndex_AvdeccFixedString, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::JackIndex const jackIndex, la::avdecc::entity::model::AvdeccFixedString const& name);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_AvbInterfaceIndex_AvdeccFixedString, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::AvbInterfaceIndex const avbInterfaceIndex, la::avdecc::entity::model::AvdeccFixedString const& name);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_ClockSourceIndex_AvdeccFixedString, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::ClockSourceIndex const clockSourceIndex, la::avdecc::entity::model::AvdeccFixedString const& name);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_MemoryObjectIndex_AvdeccFixedString, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::MemoryObjectIndex const memoryObjectIndex, la::avdecc::entity::model::AvdeccFixedString const& name);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_ClusterIndex_AvdeccFixedString, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::ClusterIndex const audioClusterIndex, la::avdecc::entity::model::AvdeccFixedString const& name);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_ControlIndex_AvdeccFixedString, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::ControlIndex const controlIndex, la::avdecc::entity::model::AvdeccFixedString const& name);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_ClockDomainIndex_AvdeccFixedString, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::ClockDomainIndex const clockDomainIndex, la::avdecc::entity::model::AvdeccFixedString const& name);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_TimingIndex_AvdeccFixedString, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::TimingIndex const timingIndex, la::avdecc::entity::model::AvdeccFixedString const& name);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_PtpInstanceIndex_AvdeccFixedString, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::PtpInstanceIndex const ptpInstanceIndex, la::avdecc::entity::model::AvdeccFixedString const& name);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_PtpPortIndex_AvdeccFixedString, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::PtpPortIndex const ptpPortIndex, la::avdecc::entity::model::AvdeccFixedString const& name);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_AudioUnitIndex_SamplingRate, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::AudioUnitIndex const audioUnitIndex, la::avdecc::entity::model::SamplingRate const samplingRate);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ClusterIndex_SamplingRate, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ClusterIndex const clusterIndex, la::avdecc::entity::model::SamplingRate const samplingRate);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_StreamIndex, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::StreamIndex const streamIndex);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_MemoryObjectIndex, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::MemoryObjectIndex const memoryObjectIndex);
#else
%std_function(Handler_UniqueIdentifier_AemCommandStatus_DescriptorIndex, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::DescriptorIndex const descriptorIndex);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_DescriptorIndex_AvdeccFixedString, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::DescriptorIndex const descriptorIndex, la::avdecc::entity::model::AvdeccFixedString const& name);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_DescriptorIndex_SamplingRate, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::DescriptorIndex const descriptorIndex, la::avdecc::entity::model::SamplingRate const samplingRate);
#endif
%std_function(Handler_UniqueIdentifier_AemCommandStatus_UniqueIdentifier, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::UniqueIdentifier const associationID);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ClockDomainIndex_ClockSourceIndex, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ClockDomainIndex const clockDomainIndex, la::avdecc::entity::model::ClockSourceIndex const clockSourceIndex);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ControlIndex_MemoryBuffer, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ControlIndex const controlIndex, la::avdecc::MemoryBuffer const& packedControlValues);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_AvbInterfaceIndex_AvbInfo, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::AvbInterfaceIndex const avbInterfaceIndex, la::avdecc::entity::model::AvbInfo const& info);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_AvbInterfaceIndex_AsPath, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::AvbInterfaceIndex const avbInterfaceIndex, la::avdecc::entity::model::AsPath const& asPath);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_EntityCounterValidFlags_DescriptorCounters, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::EntityCounterValidFlags const validCounters, la::avdecc::entity::model::DescriptorCounters const& counters);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_AvbInterfaceIndex_AvbInterfaceCounterValidFlags_DescriptorCounters, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::AvbInterfaceIndex const avbInterfaceIndex, la::avdecc::entity::AvbInterfaceCounterValidFlags const validCounters, la::avdecc::entity::model::DescriptorCounters const& counters);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ClockDomainIndex_ClockDomainCounterValidFlags_DescriptorCounters, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ClockDomainIndex const clockDomainIndex, la::avdecc::entity::ClockDomainCounterValidFlags const validCounters, la::avdecc::entity::model::DescriptorCounters const& counters);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_StreamIndex_StreamInputCounterValidFlags_DescriptorCounters, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::StreamIndex const streamIndex, la::avdecc::entity::StreamInputCounterValidFlags const validCounters, la::avdecc::entity::model::DescriptorCounters const& counters);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_StreamIndex_StreamOutputCounterValidFlags_DescriptorCounters, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::StreamIndex const streamIndex, la::avdecc::entity::StreamOutputCounterValidFlags const validCounters, la::avdecc::entity::model::DescriptorCounters const& counters);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_DescriptorType_DescriptorIndex_OperationID_MemoryObjectOperationType_MemoryBuffer, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::DescriptorType const descriptorType, la::avdecc::entity::model::DescriptorIndex const descriptorIndex, la::avdecc::entity::model::OperationID const operationID, la::avdecc::entity::model::MemoryObjectOperationType const operationType, la::avdecc::MemoryBuffer const& memoryBuffer);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_DescriptorType_DescriptorIndex_OperationID, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::DescriptorType const descriptorType, la::avdecc::entity::model::DescriptorIndex const descriptorIndex, la::avdecc::entity::model::OperationID const operationID);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_ConfigurationIndex_MemoryObjectIndex_uint64_t, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::ConfigurationIndex const configurationIndex, la::avdecc::entity::model::MemoryObjectIndex const memoryObjectIndex, std::uint64_t const length);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_StreamIndex_nanoseconds, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::model::StreamIndex const streamIndex, std::chrono::nanoseconds const& maxTransitTime);
#if 0
%rename("$ignore") la::avdecc::entity::controller::Interface::getDynamicInfo; // Temp ignore method
%rename("$ignore") la::avdecc::entity::controller::Interface::addressAccess; // Temp ignore method
#else
%std_function(Handler_UniqueIdentifier_AemCommandStatus_DynamicInfoParameter, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AemCommandStatus const status, la::avdecc::entity::controller::DynamicInfoParameters const& parameters);
%std_function(Handler_UniqueIdentifier_AemCommandStatus_Tlvs, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::AaCommandStatus const status, la::avdecc::entity::addressAccess::Tlvs const& tlvs);
#endif
%std_function(Handler_UniqueIdentifier_MvuCommandStatus_MilanInfo, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::MvuCommandStatus const status, la::avdecc::entity::model::MilanInfo const& info);
%std_function(Handler_UniqueIdentifier_MvuCommandStatus_SystemUniqueIdentifier, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::MvuCommandStatus const status, la::avdecc::entity::model::SystemUniqueIdentifier const systemUniqueID);
%std_function(Handler_UniqueIdentifier_MvuCommandStatus_ClockDomainIndex_DefaultMediaClockReferencePriority_MediaClockReferenceInfo, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::UniqueIdentifier const entityID, la::avdecc::entity::LocalEntity::MvuCommandStatus const status, la::avdecc::entity::model::ClockDomainIndex const clockDomainIndex, la::avdecc::entity::model::DefaultMediaClockReferencePriority const defaultPriority, la::avdecc::entity::model::MediaClockReferenceInfo const& mcrInfo);
%std_function(Handler_StreamIdentification_StreamIdentification_uint16_t_ConnectionFlags_ControlStatus, void, la::avdecc::entity::controller::Interface const* const controller, la::avdecc::entity::model::StreamIdentification const& talkerStream, la::avdecc::entity::model::StreamIdentification const& listenerStream, std::uint16_t const connectionCount, la::avdecc::entity::ConnectionFlags const flags, la::avdecc::entity::LocalEntity::ControlStatus const status);

%nspace la::avdecc::entity::ControllerEntity;
%rename("%s") la::avdecc::entity::ControllerEntity; // Unignore class
%ignore la::avdecc::entity::ControllerEntity::create; // Prevent direct creation of a ControllerEntity for now at it won't be usable because of double inheritance (controller::Interface methods not available)
%ignore la::avdecc::entity::ControllerEntity::ControllerEntity(ControllerEntity&&); // Ignore move constructor
%ignore la::avdecc::entity::ControllerEntity::operator=; // Ignore copy operator

// Include c++ declaration file
%include "la/avdecc/internals/controllerEntity.hpp"
%rename("%s", %$isclass) ""; // Undo the ignore all structs/classes

// Define templates
#if 1
// Ignore DynamicInfoParameter related templates until we can bind std::any
#else
%template(DynamicInfoParameters) std::vector<la::avdecc::entity::controller::DynamicInfoParameter>;
%template(AnyVector) std::vector<std::any>;
#endif


////////////////////////////////////////
// Protocol Interface
////////////////////////////////////////
// Bind enums
DEFINE_ENUM_CLASS(la::avdecc::protocol::ProtocolInterface::Type, "uint")

// Bind structs and classes
%rename($ignore, %$isclass) ""; // Ignore all structs/classes, manually re-enable

%nspace la::avdecc::protocol::ProtocolInterface;
%rename("%s") la::avdecc::protocol::ProtocolInterface; // Unignore class
%rename("Lock") la::avdecc::protocol::ProtocolInterface::lock; // Reserved keyword
%rename("Unlock") la::avdecc::protocol::ProtocolInterface::lock; // Rename as well to match "lock" renaming
//%ignore la::avdecc::protocol::ProtocolInterface::ProtocolInterface(ProtocolInterface&&); // Ignore move constructor
//%ignore la::avdecc::protocol::ProtocolInterface::operator=; // Ignore copy operator
%ignore la::avdecc::protocol::ProtocolInterface::registerVendorUniqueDelegate; // Ignore method (we don't want to handle VendorUniqueDelegate now)
%ignore la::avdecc::protocol::ProtocolInterface::unregisterVendorUniqueDelegate; // Ignore method (we don't want to handle VendorUniqueDelegate now)
%ignore la::avdecc::protocol::ProtocolInterface::unregisterAllVendorUniqueDelegates; // Ignore method (we don't want to handle VendorUniqueDelegate now)
%ignore la::avdecc::protocol::ProtocolInterface::sendAdpMessage; // Ignore method (we don't want to handle Adpdu now)
%ignore la::avdecc::protocol::ProtocolInterface::sendAecpMessage; // Ignore method (we don't want to handle Aecpdu now)
%ignore la::avdecc::protocol::ProtocolInterface::sendAcmpMessage; // Ignore method (we don't want to handle Acmpdu now)
%ignore la::avdecc::protocol::ProtocolInterface::sendAecpCommand; // Ignore method (we don't want to handle Aecpdu now)
%ignore la::avdecc::protocol::ProtocolInterface::sendAecpResponse; // Ignore method (we don't want to handle Aecpdu now)
%ignore la::avdecc::protocol::ProtocolInterface::sendAcmpCommand; // Ignore method (we don't want to handle Acmpdu now)
%ignore la::avdecc::protocol::ProtocolInterface::sendAcmpResponse; // Ignore method (we don't want to handle Acmpdu now)
%ignore la::avdecc::protocol::ProtocolInterface::getVendorUniqueCommandTimeout; // Ignore method (we don't want to handle VuAecpdu now)
%ignore la::avdecc::protocol::ProtocolInterface::isVendorUniqueUnsolicitedResponse; // Ignore method (we don't want to handle VuAecpdu now)
%ignore la::avdecc::protocol::ProtocolInterface::handleVendorUniqueUnsolicitedResponse; // Ignore method (we don't want to handle VuAecpdu now)
%ignore la::avdecc::protocol::ProtocolInterface::getVendorUniqueDelegate; // Ignore method (we don't want to handle VuAecpdu now)
%unique_ptr(la::avdecc::protocol::ProtocolInterface) // Define unique_ptr for ProtocolInterface
// Extend the class
%extend la::avdecc::protocol::ProtocolInterface
{
public:
	static std::unique_ptr<la::avdecc::protocol::ProtocolInterface> create(la::avdecc::protocol::ProtocolInterface::Type const protocolInterfaceType, std::string const& networkInterfaceID, std::string const& executorName)
	{
		try
		{
			return std::unique_ptr<la::avdecc::protocol::ProtocolInterface>{ la::avdecc::protocol::ProtocolInterface::create(protocolInterfaceType, networkInterfaceID, executorName).release() };
		}
		catch (la::avdecc::protocol::ProtocolInterface::Exception const& e)
		{
			SWIG_CSharpSetPendingExceptionProtocolInterface(e.getError(), e.what());
			return nullptr;
		}
	}
};
%ignore la::avdecc::protocol::ProtocolInterface::create; // Ignore it, will be wrapped (because std::unique_ptr doesn't support custom deleters - Ticket #2411)

// Throw typemap
%typemap (throws, canthrow=1) la::avdecc::protocol::ProtocolInterface::Exception %{
	SWIG_CSharpSetPendingExceptionProtocolInterface($1.getError(), $1.what());
	return $null;
%}

// Define catches for methods that can throw
%catches(la::avdecc::protocol::ProtocolInterface::Exception) la::avdecc::protocol::ProtocolInterface::create;

// Include c++ declaration file
%include "la/avdecc/internals/protocolInterface.hpp"
%rename("%s", %$isclass) ""; // Undo the ignore all structs/classes

// Define templates
DEFINE_ENUM_BITFIELD_CLASS(la::avdecc::protocol::ProtocolInterface, SupportedProtocolInterfaceTypes, Type, std::uint32_t)


////////////////////////////////////////
// Entity Model Tree
////////////////////////////////////////
// Define some macros
%define DEFINE_AEM_TREE_COMMON(name)
	%nspace la::avdecc::entity::model::name;
	%rename("%s") la::avdecc::entity::model::name; // Unignore class
	%rename("isEqual") operator==(name const& lhs, name const& rhs) noexcept; // Not put in a namespace https://github.com/swig/swig/issues/2459
	%rename("isDifferent") operator!=(name const& lhs, name const& rhs) noexcept; // Not put in a namespace https://github.com/swig/swig/issues/2459
	// Extend the struct
	%extend la::avdecc::entity::model::name
	{
		// Add default constructor
		name()
		{
			return new la::avdecc::entity::model::name();
		}
		// Add a copy-constructor
		name(la::avdecc::entity::model::name const& other)
		{
			return new la::avdecc::entity::model::name(other);
		}
#if defined(SWIGCSHARP)
		// Provide a more native Equals() method
		bool Equals(la::avdecc::entity::model::name const& other) const noexcept
		{
			return *$self == other;
		}
#endif
	}
%enddef
%define DEFINE_AEM_TREE_MODELS(name)
	%nspace la::avdecc::entity::model::name##NodeDynamicModel;
	%rename("%s") la::avdecc::entity::model::name##NodeDynamicModel; // Unignore class
	// Extend the struct
	%extend la::avdecc::entity::model::name##NodeDynamicModel
	{
		// Add default constructor
		name##NodeDynamicModel()
		{
			return new la::avdecc::entity::model::name##NodeDynamicModel();
		}
		// Add a copy-constructor
		name##NodeDynamicModel(la::avdecc::entity::model::name##NodeDynamicModel const& other)
		{
			return new la::avdecc::entity::model::name##NodeDynamicModel(other);
		}
	}
	%nspace la::avdecc::entity::model::name##NodeStaticModel;
	%rename("%s") la::avdecc::entity::model::name##NodeStaticModel; // Unignore class
	// Extend the struct
	%extend la::avdecc::entity::model::name##NodeStaticModel
	{
		// Add default constructor
		name##NodeStaticModel()
		{
			return new la::avdecc::entity::model::name##NodeStaticModel();
		}
		// Add a copy-constructor
		name##NodeStaticModel(la::avdecc::entity::model::name##NodeStaticModel const& other)
		{
			return new la::avdecc::entity::model::name##NodeStaticModel(other);
		}
	}
%enddef
%define DEFINE_AEM_TREE_NODE(name)
	%nspace la::avdecc::entity::model::name##Tree;
	%rename("%s") la::avdecc::entity::model::name##Tree; // Unignore class
	// Extend the struct
	%extend la::avdecc::entity::model::name##Tree
	{
		// Add default constructor
		name##Tree()
		{
			return new la::avdecc::entity::model::name##Tree();
		}
		// Add a copy-constructor
		name##Tree(la::avdecc::entity::model::name##Tree const& other)
		{
			return new la::avdecc::entity::model::name##Tree(other);
		}
	}
%enddef
%define DEFINE_AEM_TREE_LEAF(name)
	%nspace la::avdecc::entity::model::name##NodeModels;
	%rename("%s") la::avdecc::entity::model::name##NodeModels; // Unignore class
	// Extend the struct
	%extend la::avdecc::entity::model::name##NodeModels
	{
		// Add default constructor
		name##NodeModels()
		{
			return new la::avdecc::entity::model::name##NodeModels();
		}
		// Add a copy-constructor
		name##NodeModels(la::avdecc::entity::model::name##NodeModels const& other)
		{
			return new la::avdecc::entity::model::name##NodeModels(other);
		}
	}
%enddef

// Define optionals
%optional_arithmetic(std::uint16_t, OptUInt16)
%optional_arithmetic(std::uint64_t, OptUInt64)
%optional_arithmetic(bool, OptBool)
%optional(la::avdecc::entity::model::StreamDynamicInfo)
%optional(la::avdecc::entity::model::AvbInterfaceInfo)
%optional(la::avdecc::entity::model::AsPath)
%optional(la::avdecc::entity::model::EntityCounters)
%optional(la::avdecc::entity::model::StreamInputCounters)
%optional(la::avdecc::entity::model::StreamOutputCounters)
%optional(la::avdecc::entity::model::AvbInterfaceCounters)
%optional(la::avdecc::entity::model::ClockDomainCounters)

// Bind structs and classes
%rename($ignore, %$isclass) ""; // Ignore all structs/classes, manually re-enable
DEFINE_AEM_TREE_COMMON(StreamInputConnectionInfo)
DEFINE_AEM_TREE_COMMON(StreamDynamicInfo)
DEFINE_AEM_TREE_COMMON(AvbInterfaceInfo)
DEFINE_AEM_TREE_MODELS(AudioUnit)
DEFINE_AEM_TREE_MODELS(Stream)
DEFINE_AEM_TREE_MODELS(StreamInput)
DEFINE_AEM_TREE_MODELS(StreamOutput)
DEFINE_AEM_TREE_MODELS(Jack)
DEFINE_AEM_TREE_MODELS(AvbInterface)
DEFINE_AEM_TREE_MODELS(ClockSource)
DEFINE_AEM_TREE_MODELS(MemoryObject)
DEFINE_AEM_TREE_MODELS(Locale)
DEFINE_AEM_TREE_MODELS(Strings)
DEFINE_AEM_TREE_MODELS(StreamPort)
DEFINE_AEM_TREE_MODELS(AudioCluster)
DEFINE_AEM_TREE_MODELS(AudioMap)
DEFINE_AEM_TREE_MODELS(Control)
DEFINE_AEM_TREE_MODELS(ClockDomain)
DEFINE_AEM_TREE_MODELS(Timing)
DEFINE_AEM_TREE_MODELS(PtpInstance)
DEFINE_AEM_TREE_MODELS(PtpPort)
DEFINE_AEM_TREE_MODELS(Configuration)
DEFINE_AEM_TREE_MODELS(Entity)
DEFINE_AEM_TREE_LEAF(StreamInput);
DEFINE_AEM_TREE_LEAF(StreamOutput);
DEFINE_AEM_TREE_LEAF(AvbInterface);
DEFINE_AEM_TREE_LEAF(ClockSource);
DEFINE_AEM_TREE_LEAF(MemoryObject);
DEFINE_AEM_TREE_LEAF(Strings);
DEFINE_AEM_TREE_LEAF(AudioCluster);
DEFINE_AEM_TREE_LEAF(AudioMap);
DEFINE_AEM_TREE_LEAF(Control);
DEFINE_AEM_TREE_LEAF(ClockDomain);
DEFINE_AEM_TREE_LEAF(Timing);
DEFINE_AEM_TREE_LEAF(PtpPort);
DEFINE_AEM_TREE_NODE(Jack);
DEFINE_AEM_TREE_NODE(Locale);
DEFINE_AEM_TREE_NODE(StreamPort);
DEFINE_AEM_TREE_NODE(AudioUnit);
DEFINE_AEM_TREE_NODE(PtpInstance);
DEFINE_AEM_TREE_NODE(Configuration);
DEFINE_AEM_TREE_NODE(Entity);

// Include c++ declaration file
%include "la/avdecc/internals/entityModelTreeCommon.hpp"
%include "la/avdecc/internals/entityModelTreeDynamic.hpp"
%include "la/avdecc/internals/entityModelTreeStatic.hpp"
%include "la/avdecc/internals/entityModelTree.hpp"
%rename("%s", %$isclass) ""; // Undo the ignore all structs/classes

// Define templates
%template(StreamIdentificationSet) std::set<la::avdecc::entity::model::StreamIdentification>;
%template(ControlNodeModelMap) std::map<la::avdecc::entity::model::ControlIndex, la::avdecc::entity::model::ControlNodeModels>;
%template(StringsNodeModelMap) std::map<la::avdecc::entity::model::StringsIndex, la::avdecc::entity::model::StringsNodeModels>;
%template(AudioClusterNodeModelMap) std::map<la::avdecc::entity::model::ClusterIndex, la::avdecc::entity::model::AudioClusterNodeModels>;
%template(AudioMapNodeModelMap) std::map<la::avdecc::entity::model::MapIndex, la::avdecc::entity::model::AudioMapNodeModels>;
%template(StreamPortTreeMap) std::map<la::avdecc::entity::model::StreamPortIndex, la::avdecc::entity::model::StreamPortTree>;
%template(AudioUnitTreeMap) std::map<la::avdecc::entity::model::AudioUnitIndex, la::avdecc::entity::model::AudioUnitTree>;
%template(LocaleTreeMap) std::map<la::avdecc::entity::model::LocaleIndex, la::avdecc::entity::model::LocaleTree>;
%template(JackTreeMap) std::map<la::avdecc::entity::model::JackIndex, la::avdecc::entity::model::JackTree>;
%template(PtpInstanceTreeMap) std::map<la::avdecc::entity::model::PtpInstanceIndex, la::avdecc::entity::model::PtpInstanceTree>;
%template(StreamInputNodeModelMap) std::map<la::avdecc::entity::model::StreamIndex, la::avdecc::entity::model::StreamInputNodeModels>;
%template(StreamOutputNodeModelMap) std::map<la::avdecc::entity::model::StreamIndex, la::avdecc::entity::model::StreamOutputNodeModels>;
%template(AvbInterfaceNodeModelMap) std::map<la::avdecc::entity::model::AvbInterfaceIndex, la::avdecc::entity::model::AvbInterfaceNodeModels>;
%template(ClockSourceNodeModelMap) std::map<la::avdecc::entity::model::ClockSourceIndex, la::avdecc::entity::model::ClockSourceNodeModels>;
%template(MemoryObjectNodeModelMap) std::map<la::avdecc::entity::model::MemoryObjectIndex, la::avdecc::entity::model::MemoryObjectNodeModels>;
%template(ClockDomainNodeModelMap) std::map<la::avdecc::entity::model::ClockDomainIndex, la::avdecc::entity::model::ClockDomainNodeModels>;
%template(TimingNodeModelMap) std::map<la::avdecc::entity::model::TimingIndex, la::avdecc::entity::model::TimingNodeModels>;
%template(PtpPortNodeModelMap) std::map<la::avdecc::entity::model::PtpPortIndex, la::avdecc::entity::model::PtpPortNodeModels>;
%template(ConfigurationTreeMap) std::map<la::avdecc::entity::model::ConfigurationIndex, la::avdecc::entity::model::ConfigurationTree>;
%template(EntityCounters) std::map<la::avdecc::entity::EntityCounterValidFlag, la::avdecc::entity::model::DescriptorCounter>;
%template(StreamInputCounters) std::map<la::avdecc::entity::StreamInputCounterValidFlag, la::avdecc::entity::model::DescriptorCounter>;
%template(StreamOutputCounters) std::map<la::avdecc::entity::StreamOutputCounterValidFlag, la::avdecc::entity::model::DescriptorCounter>;
%template(StreamOutputCounters17221) std::map<la::avdecc::entity::StreamOutputCounterValidFlag17221, la::avdecc::entity::model::DescriptorCounter>;
%template(AvbInterfaceCounters) std::map<la::avdecc::entity::AvbInterfaceCounterValidFlag, la::avdecc::entity::model::DescriptorCounter>;
%template(ClockDomainCounters) std::map<la::avdecc::entity::ClockDomainCounterValidFlag, la::avdecc::entity::model::DescriptorCounter>;
%template(LocalizedStringMap) std::unordered_map<la::avdecc::entity::model::StringsIndex, la::avdecc::entity::model::AvdeccFixedString>;

////////////////////////////////////////
// JSON SERIALIZATION
////////////////////////////////////////
// Bind enums
DEFINE_ENUM_CLASS(la::avdecc::entity::model::jsonSerializer::Flag, "ushort")

// Include c++ declaration file
%include "la/avdecc/internals/jsonSerialization.hpp"
%rename("%s", %$isclass) ""; // Undo the ignore all structs/classes

// Define templates
DEFINE_ENUM_BITFIELD_CLASS(la::avdecc::entity::model::jsonSerializer, Flags, Flag, std::uint16_t)


////////////////////////////////////////
// EndStation
////////////////////////////////////////
// Bind structs and classes
%rename($ignore, %$isclass) ""; // Ignore all structs/classes, manually re-enable

%nspace la::avdecc::EndStation;
%rename("%s") la::avdecc::EndStation; // Unignore class
%ignore la::avdecc::EndStation::Exception; // Ignore Exception, will be created as native exception
%ignore la::avdecc::EndStation::addAggregateEntity; // Ignore at the moment, we don't want to handle AggregateEntity yet
%ignore la::avdecc::EndStation::deserializeEntityModelFromJson;
%unique_ptr(la::avdecc::EndStation) // Define unique_ptr for EndStation
// Extend the class
%extend la::avdecc::EndStation
{
public:
	static std::unique_ptr<la::avdecc::EndStation> create(protocol::ProtocolInterface::Type const protocolInterfaceType, std::string const& networkInterfaceID, std::optional<std::string> const& executorName)
	{
		try
		{
			return std::unique_ptr<la::avdecc::EndStation>{ la::avdecc::EndStation::create(protocolInterfaceType, networkInterfaceID, executorName).release() };
		}
		catch (la::avdecc::EndStation::Exception const& e)
		{
			SWIG_CSharpSetPendingExceptionEndStation(e.getError(), e.what());
			return nullptr;
		}
	}
};
%ignore la::avdecc::EndStation::create; // Ignore it, will be wrapped (because std::unique_ptr doesn't support custom deleters - Ticket #2411)

// Throw typemap
%typemap (throws, canthrow=1) la::avdecc::EndStation::Exception %{
	SWIG_CSharpSetPendingExceptionEndStation($1.getError(), $1.what());
	return $null;
%}

// Define catches for methods that can throw
%catches(la::avdecc::EndStation::Exception) la::avdecc::EndStation::create;

// Include c++ declaration file
%include "la/avdecc/internals/endStation.hpp"
%rename("%s", %$isclass) ""; // Undo the ignore all structs/classes


// Define C# exception handling
%insert(runtime) %{
	// la::avdecc::Exception
	typedef void (SWIGSTDCALL* ExceptionCallback_t)(char const* const message);
	ExceptionCallback_t exceptionCallback = NULL;

	extern "C" SWIGEXPORT void SWIGSTDCALL ExceptionRegisterCallback(ExceptionCallback_t cb)
	{
		exceptionCallback = cb;
	}

	static void SWIG_CSharpSetPendingException(char const* const message)
	{
		exceptionCallback(message);
	}

	// la::avdecc::protocol::ProtocolInterface::Exception
	typedef void (SWIGSTDCALL* ProtocolInterfaceExceptionCallback_t)(la::avdecc::protocol::ProtocolInterface::Error const error, char const* const message);
	ProtocolInterfaceExceptionCallback_t protocolInterfaceExceptionCallback = NULL;

	extern "C" SWIGEXPORT void SWIGSTDCALL ProtocolInterfaceExceptionRegisterCallback(ProtocolInterfaceExceptionCallback_t cb)
	{
		protocolInterfaceExceptionCallback = cb;
	}

	static void SWIG_CSharpSetPendingExceptionProtocolInterface(la::avdecc::protocol::ProtocolInterface::Error const error, char const* const message)
	{
		protocolInterfaceExceptionCallback(error, message);
	}

	// la::avdecc::EndStation::Exception
	typedef void (SWIGSTDCALL* EndStationExceptionCallback_t)(la::avdecc::EndStation::Error const error, char const* const message);
	EndStationExceptionCallback_t endStationExceptionCallback = NULL;

	extern "C" SWIGEXPORT void SWIGSTDCALL EndStationExceptionRegisterCallback(EndStationExceptionCallback_t cb)
	{
		endStationExceptionCallback = cb;
	}

	static void SWIG_CSharpSetPendingExceptionEndStation(la::avdecc::EndStation::Error const error, char const* const message)
	{
		endStationExceptionCallback(error, message);
	}
%}
%pragma(csharp) imclasscode=%{
	// la::avdecc::Exception
	class ExceptionHelper
	{
		public delegate void ExceptionDelegate(string message);
		static ExceptionDelegate exceptionDelegate = new ExceptionDelegate(SetPendingException);

		[global::System.Runtime.InteropServices.DllImport("$dllimport", EntryPoint="ExceptionRegisterCallback")]
		public static extern void ExceptionRegisterCallback(ExceptionDelegate exceptionDelegate);

		static void SetPendingException(string message)
		{
			SWIGPendingException.Set(new la.avdecc.Exception(message));
		}

		static ExceptionHelper()
		{
			ExceptionRegisterCallback(exceptionDelegate);
		}
	}
	static ExceptionHelper exceptionHelper = new ExceptionHelper();

	// la::avdecc::protocol::ProtocolInterface::Exception
	class ProtocolInterfaceExceptionHelper
	{
		public delegate void ProtocolInterfaceExceptionDelegate(la.avdecc.protocol.ProtocolInterfaceException.Error error, string message);
		static ProtocolInterfaceExceptionDelegate protocolInterfaceDelegate = new ProtocolInterfaceExceptionDelegate(SetPendingProtocolInterfaceException);

		[global::System.Runtime.InteropServices.DllImport("$dllimport", EntryPoint="ProtocolInterfaceExceptionRegisterCallback")]
		public static extern void ProtocolInterfaceExceptionRegisterCallback(ProtocolInterfaceExceptionDelegate protocolInterfaceDelegate);

		static void SetPendingProtocolInterfaceException(la.avdecc.protocol.ProtocolInterfaceException.Error error, string message)
		{
			SWIGPendingException.Set(new la.avdecc.protocol.ProtocolInterfaceException(error, message));
		}

		static ProtocolInterfaceExceptionHelper()
		{
			ProtocolInterfaceExceptionRegisterCallback(protocolInterfaceDelegate);
		}
	}
	static ProtocolInterfaceExceptionHelper protocolInterfaceExceptionHelper = new ProtocolInterfaceExceptionHelper();

	// la::avdecc::EndStation::Exception
	class EndStationExceptionHelper
	{
		public delegate void EndStationExceptionDelegate(la.avdecc.EndStationException.Error error, string message);
		static EndStationExceptionDelegate endStationDelegate = new EndStationExceptionDelegate(SetPendingEndStationException);

		[global::System.Runtime.InteropServices.DllImport("$dllimport", EntryPoint="EndStationExceptionRegisterCallback")]
		public static extern void EndStationExceptionRegisterCallback(EndStationExceptionDelegate endStationDelegate);

		static void SetPendingEndStationException(la.avdecc.EndStationException.Error error, string message)
		{
			SWIGPendingException.Set(new la.avdecc.EndStationException(error, message));
		}

		static EndStationExceptionHelper()
		{
			EndStationExceptionRegisterCallback(endStationDelegate);
		}
	}
	static EndStationExceptionHelper endStationExceptionHelper = new EndStationExceptionHelper();
%}
%pragma(csharp) moduleimports=%{
namespace la.avdecc
{
	// la::avdecc::Exception
	public class Exception : global::System.ApplicationException
	{
		public Exception(string message)
			: base(message)
		{
		}
	}

	// la::avdecc::EndStation::Exception
	public class EndStationException : global::System.ApplicationException
	{
		public enum Error
		{
			NoError = 0,
			InvalidProtocolInterfaceType = 1, /**< Selected protocol interface type is invalid. */
			InterfaceOpenError = 2, /**< Failed to open interface. */
			InterfaceNotFound = 3, /**< Specified interface not found. */
			InterfaceInvalid = 4, /**< Specified interface is invalid. */
			DuplicateEntityID = 5, /**< EntityID not available (either duplicate, or no EntityID left on the local computer). */
			InvalidEntityModel = 6, /**< Provided EntityModel is invalid. */
			DuplicateExecutorName = 7, /**< Provided executor name already exists. */
			UnknownExecutorName = 8, /**< Provided executor name doesn't exist. */
			InternalError = 99, /**< Internal error, please report the issue. */
		}
		public EndStationException(Error error, string message)
			: base(message)
		{
			_error = error;
		}
		public Error getError()
		{
			return _error;
		}
		private Error _error = Error.NoError;
	}

	namespace protocol
	{
		// la::avdecc::protocol::ProtocolInterface::Exception
		public class ProtocolInterfaceException : global::System.ApplicationException
		{
			public enum Error
			{
				NoError = 0,
				TransportError = 1, /**< Transport interface error. This is critical and the interface is no longer usable. */
				Timeout = 2, /**< A timeout occured during the operation. */
				UnknownRemoteEntity = 3, /**< Unknown remote entity. */
				UnknownLocalEntity = 4, /**< Unknown local entity. */
				InvalidEntityType = 5, /**< Invalid entity type for the operation. */
				DuplicateLocalEntityID = 6, /**< The EntityID specified in a LocalEntity is already in use by another local entity. */
				InterfaceNotFound = 7, /**< Specified InterfaceID not found. */
				InvalidParameters = 8, /**< Specified parameters are invalid. */
				InterfaceNotSupported = 9, /**< This protocol interface is not in the list of supported protocol interfaces. */
				MessageNotSupported = 10, /**< This type of message is not supported by this protocol interface. */
				ExecutorNotInitialized = 11, /**< The executor is not initialized. */
				InternalError = 99, /**< Internal error, please report the issue. */
			}
			public ProtocolInterfaceException(Error error, string message)
				: base(message)
			{
				_error = error;
			}
			public Error getError()
			{
				return _error;
			}
			private Error _error = Error.NoError;
		}
	}
}
%}
